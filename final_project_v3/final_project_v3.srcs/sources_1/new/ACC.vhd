library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use work.DigEng.ALL;

entity ACC is

    -- Default values for data_size and M which are used to generate width of coefficient in C
    generic(data_size: natural := 5;
            M: natural := 3);
    
    -- Define ports in ACC
    Port ( clk       : in STD_LOGIC;
           rst       : in STD_LOGIC;
           input_acc : in STD_LOGIC_VECTOR(size(((2**(data_size - 1))**2)*M) downto 0); -- widths of input and output are same
           en        : in STD_LOGIC; -- enable to tell macc when to store the sum from addition, generated by FSM
           
           output_acc: out STD_LOGIC_VECTOR (size(((2**(data_size - 1))**2)*M) downto 0)); -- equation derivation is in report: (size(((2**(data_size - 1))**2)*M)+1)-1
end ACC;

architecture Behavioral of ACC is

begin

    -- Define a process of ACC
    -- ACC is like a register to take the input from adder and give the output back to one input of adder
    -- Once one coefficient of matrix C has been calculated, 
    -- there should be an enable signal to enable ACC to give output to RAM instead of adder
    -- Initially, the output and the input are set to 0 for ACC
    -- rst signal for ACC will set all values back to 0 
    acc: process(clk, en)
    begin
        if(rising_edge(clk)) then
            if(rst = '1') then -- with synchronous reset
                output_acc <= (others => '0'); -- When reset is pressed
            elsif(en = '1') then -- with wynchronous enable
                output_acc <= input_acc;
            end if;
        end if;
    end process acc;
                      
end Behavioral;
